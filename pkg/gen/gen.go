package gen

import (
	"aocgen/pkg/common"
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"
	"regexp"
	"strconv"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/dolmen-go/codegen"
	"github.com/sirupsen/logrus"
)

const yearsFile = "./pkg/years/years.go"

var validPuzzleFile = regexp.MustCompile(`^day[0-3][0-9]$`)

func puzzlePath(year int) string {
	return fmt.Sprintf("./pkg/year%d", year)
}

func puzzleFileName(year, day int) string {
	path := puzzlePath(year)
	return fmt.Sprintf("%s/day%s.go", path, FormatDay(day))
}

func puzzleInputPath(year int) string {
	return fmt.Sprintf("./pkg/year%d/inputs", year)
}

func puzzleInputFileName(year, day int) string {
	path := puzzleInputPath(year)
	return fmt.Sprintf("%s/%d.txt", path, day)
}

func puzzleSampleFileName(year, day int) string {
	path := puzzleInputPath(year)
	return fmt.Sprintf("%s/%d-sample.txt", path, day)
}

// Generate yearXXXX directory if not exists
func newYearPkgDirectory(year int) {
	path := puzzlePath(year)
	if err := createDirectory(path); err != nil {
		logrus.Fatal(err)
	}
}

func createDirectory(path string) error {
	if _, err := os.Stat(path); err == nil || !errors.Is(err, os.ErrNotExist) {
		logrus.Infof("Directory already exists: %s", path)
		return nil
	}

	err := os.Mkdir(path, os.ModePerm)
	if err != nil {
		return err
	}

	logrus.Infof("Created directory: %s", path)
	return nil
}

// Generate inputs directory if not exists, retrieve input file
func NewInputFile(year, day int) {
	path := puzzleInputPath(year)
	inputFileName := puzzleInputFileName(year, day)

	if _, err := os.Stat(inputFileName); err != nil && err == os.ErrNotExist {
		logrus.Infof("Input file already exists: %s", inputFileName)
		return
	}

	err := createDirectory(path)
	if err != nil {
		logrus.Fatal(err)
	}

	f, err := os.Create(inputFileName)
	if err != nil {
		logrus.Fatal(err)
	}
	defer f.Close()

	logrus.Infof("Generated empty input file: %s", inputFileName)

	webInput := string(WebInput(year, day))

	if webInput != "" {
		logrus.Infof("Fetched data from AOC website for file: %s", inputFileName)
		f.WriteString(webInput)
	}
}

// Generate inputs directory if not exists, generate empty sample file
func NewSampleFile(year, day int) {
	path := puzzleInputPath(year)
	sampleFileName := puzzleSampleFileName(year, day)

	if _, err := os.Stat(sampleFileName); err != nil && err == os.ErrNotExist {
		logrus.Infof("Sample file already exists: %s", sampleFileName)
		return
	}

	err := createDirectory(path)
	if err != nil {
		logrus.Fatal(err)
	}

	f, err := os.Create(sampleFileName)
	if err != nil {
		logrus.Fatal(err)
	}
	defer f.Close()

	// leaving it empty for the user. grabbing a sample from the prompt is fraught
	logrus.Infof("Generated empty sample file: %s", sampleFileName)
}

const puzzleTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package year{{.Year}}

	type Day{{.Day}} struct{}

	func (p *Day{{.Day}}) parseInput(lines []string) {
		for _, line := range lines[:len(lines)-1] {
				print(line)
		}
	}

	func (p Day{{.Day}}) PartA(lines []string) any {
		p.parseInput(lines)
		return "implement_me"
	}
	
	func (p Day{{.Day}}) PartB(lines []string) any {
		p.parseInput(lines)
		return "implement_me"
	}
	
`

func NewPuzzleFile(year, day int) {
	fileName := puzzleFileName(year, day)
	if _, err := os.Stat(fileName); err == nil || !errors.Is(err, os.ErrNotExist) {
		logrus.Infof("Puzzle file already exists: %s", fileName)
		return
	}

	tmpl := codegen.MustParse(puzzleTemplate)
	if err := tmpl.CreateFile(fileName, map[string]any{
		"Year": year,
		"Day":  FormatDay(day),
	}); err != nil {
		logrus.Fatal(err)
	}
	// get rid of the annoying flag that i'll have to delete manually anyway
	//  **because this is the file i have to edit!!**
	// createa a byte buffer of size filesize
	f, err := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE, 0666)
	common.Check(err)
	defer f.Close()
	fi, err := f.Stat()
	common.Check(err)
	buf := bytes.NewBuffer(make([]byte, 0, fi.Size()))

	// go to the start of the file and copy it into the buffer
	_, err = f.Seek(0, io.SeekStart)
	common.Check(err)
	_, err = io.Copy(buf, f)
	common.Check(err)

	// advance cursor past the first line, throwing away the read bytes
	_, err = buf.ReadBytes('\n')
	if err != nil && err != io.EOF {
		logrus.Fatal(err)
	}

	// go back to the start of the file again
	_, err = f.Seek(0, io.SeekStart)
	common.Check(err)

	// copy buffer into file, cursor is still after the first line
	nw, err := io.Copy(f, buf)
	common.Check(err)

	// truncate at length of buffer written (original size - first line bytes) and sync to FS
	err = f.Truncate(nw)
	common.Check(err)
	err = f.Sync()
	common.Check(err)

	logrus.Infof("Created file: %s", fileName)
}

const initPkgTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package year{{.Year}}

	import (
		"aocgen/pkg/aoc"
	)

	func Init() {
		aoc.Register({{.Year}}, map[int]aoc.Puzzle{
			{{.Puzzles}}
		})
	}
`

// Scan directory and autoload all structs in package Init func
func InitializePackage(year int) {
	path := fmt.Sprintf("./pkg/year%d", year)
	fileName := fmt.Sprintf("%s/year%d.go", path, year)
	puzzles := ""

	newYearPkgDirectory(year)
	entries, err := os.ReadDir(path)
	if err != nil {
		logrus.Fatal(err)
	}

	for _, entry := range entries {
		file, err := entry.Info()
		common.Check(err)
		if file.IsDir() {
			continue
		}
		puzzleName := strings.Split(file.Name(), ".")[0]
		if !validPuzzleFile.Match([]byte(puzzleName)) {
			continue
		}
		day, _ := strconv.Atoi(puzzleName[3:])
		caser := cases.Title(language.English)
		puzzles += fmt.Sprintf("%d: %s{},\n", day, caser.String(strings.ToLower(puzzleName)))
		logrus.Debugf("Found puzzle file for %d-%d", year, day)
	}

	tmpl := codegen.MustParse(initPkgTemplate)
	if err := tmpl.CreateFile(fileName, map[string]interface{}{
		"Year":    year,
		"Puzzles": puzzles,
	}); err != nil {
		logrus.Fatal(err)
	}

	logrus.Infof("Created init file for package: %s", fileName)
}

const initMainTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package years

	import (
		{{.Imports}}
	)

	func RegisterYears() {
		{{.Inits}}
	}
`

// InitializeYearsPackage scans directory and autoload all structs in main to call all Init funcs
func InitializeYearsPackages() {
	path := "./pkg/"

	err := os.Remove(yearsFile)
	if err != nil {
		logrus.Fatal(err)
	}
	logrus.Infof("Deleted file: %s", yearsFile)

	var imports, inits string

	dirEntries, err := os.ReadDir(path)
	if err != nil {
		logrus.Fatal(err)
	}

	for _, entry := range dirEntries {
		dir, err := entry.Info()
		common.Check(err)

		if !dir.IsDir() || len(dir.Name()) < 8 || dir.Name()[:4] != "year" {
			logrus.Infof("Skipping directory for package: %s", dir.Name())
			continue
		}
		year, _ := strconv.Atoi(dir.Name()[4:])
		logrus.Infof("Found directory to include in codegen: %d", year)

		imports += fmt.Sprintf("\"aocgen/pkg/year%d\"\n", year)
		inits += fmt.Sprintf("year%d.Init()\n", year)
	}

	tmpl := codegen.MustParse(initMainTemplate)
	if err := tmpl.CreateFile(yearsFile, map[string]interface{}{
		"Imports": imports,
		"Inits":   inits,
	}); err != nil {
		logrus.Fatal(err)
	}
}

const benchmarkingTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package year{{.Year}}

	import (
		"testing"

		"aocgen/pkg/aoc"
	)

	{{.Benchmarks}}
`

func NewBenchmarks(year int) {
	path := fmt.Sprintf("./pkg/year%d", year)
	fileName := fmt.Sprintf("%s/year%d_test.go", path, year)

	benchmarks := ""

	entries, err := os.ReadDir(path)
	common.Check(err)

	for _, entry := range entries {
		file, err := entry.Info()
		common.Check(err)
		if file.IsDir() {
			continue
		}
		puzzleName := strings.Split(file.Name(), ".")[0]
		if !validPuzzleFile.Match([]byte(puzzleName)) {
			continue
		}
		day, _ := strconv.Atoi(puzzleName[3:])
		benchmarks += fmt.Sprintf(`func Benchmark%dDay%s(b *testing.B) {
			Init()
			input := aoc.TestInput(%d, %d)
				p := aoc.NewPuzzle(%d, %d)
				b.Run("PartA", func(b *testing.B) {
					b.ResetTimer()
					for i := 0; i < b.N; i++ {
						p.PartA(input)
					}
				})
				b.Run("PartB", func(b *testing.B) {
					b.ResetTimer()
					for i := 0; i < b.N; i++ {
						p.PartB(input)
					}
				})
		}
		`, year, FormatDay(day), year, day, year, day)
	}

	tmpl := codegen.MustParse(benchmarkingTemplate)
	if err := tmpl.CreateFile(fileName, map[string]interface{}{
		"Year":       year,
		"Benchmarks": benchmarks,
	}); err != nil {
		logrus.Fatal(err)
	}

	logrus.Infof("Created file: %s", fileName)
}

func RemovePuzzle(year, day int) {
	fileName := puzzleFileName(year, day)
	err := os.Remove(fileName)
	if err != nil {
		logrus.Error(err)
		return
	}
	logrus.Info(fmt.Sprintf("File deleted: %s", fileName))

	InitializeYearsPackages()
	InitializePackage(year)
	NewBenchmarks(year)
}

func RemovePuzzleInput(year, day int) {
	fileName := puzzleInputFileName(year, day)
	err := os.Remove(fileName)
	if err != nil {
		logrus.Error(err)
		return
	}
	logrus.Info(fmt.Sprintf("File deleted: %s", fileName))

	InitializeYearsPackages()
	InitializePackage(year)
	NewBenchmarks(year)
}

func RemovePuzzleSample(year, day int) {
	fileName := puzzleSampleFileName(year, day)
	err := os.Remove(fileName)
	if err != nil {
		logrus.Error(err)
		return
	}
	logrus.Info(fmt.Sprintf("File deleted: %s", fileName))

	InitializeYearsPackages()
	InitializePackage(year)
	NewBenchmarks(year)
}

// FormatDay zero pads single-digit days
func FormatDay(year int) string {
	yearStr := strconv.Itoa(year)
	if len(yearStr) == 1 {
		return "0" + yearStr
	}
	return yearStr
}
